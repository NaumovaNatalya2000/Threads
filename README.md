# Программа для тестирования работы потоков.

Реализована программа с применением принципов многопоточности.

При открытии программы выходит основное меню, в котором можно выполнить следующие действия:

1. Ввести сообщение
   
2. Вывести строку из файла логов - строки выводятся по одной (считывание по одной строке)
   
3. Сбросить позицию чтения - для перемещения в начало файла
   
4. Выход из программы

В основном меню создается экземпляр класса Logger - для работы с файловым потоком

Также для работы с потоком записи создается вектор потоков - join выполняется в конце программы.

Для вывода сообщений потоки создаются в самом case и join-ятся там же - для корректного вывода сообщений

Для большей наглядности в потоках добавлена задержка с помощью std::this_thread::sleep_for(std::chrono...)

## Класс Logger.h + Logger.cpp

### Переменные класса:

- `std::wfstream file` - файловый поток

- `std::shared_mutex mtx` - мьютекс для защиты данных. В данном случае используется именно он, чтобы защитить данные во время записи и чтения. Во время записи мьютекс лочится эксклюзивно, во время чтения получает общую блокировку.

Для записи: `std::unique_lock<std::shared_mutex> lock(mtx);`

Для чтения: `std::shared_lock<std::shared_mutex> lock(mtx);`

- `std::streampos readPos` - позиция чтения

### Методы класса:

Реализовано 2 приватных метода для синхронизации потоков записи и чтения:

- `void SyncForWrite();` - здесь очищаем флаги ошибок и eof с помощью clear и проставляем позицию указателя записи с помощью seekp в конец файла

- `void SyncForRead();` - здесь также очищаем флаги ошибок и также устаналиваем позицию чтения, чтобы начинать с той - на которой закончили при предыдущем чтении

public методы:

- `Logger(const std::wstring& filename)` - конструктор создания экземпляра класса. В нем открываем поток для чтения и записи - проставляем флаги in, out и app (записи будут идти в конец файла). Позицию чтения устанавливаем в 0.

- `~Logger()` - деструктор. Во время выполнения деструктора эксклюзивно блокируем мьютекс для безопасности. Если файл открыт - закрываем с помощью close.

- `void WriteLine(const std::wstring& text);` - функция записи. В нее передаем строку, эксклюзивно блокируем мьютекс, выполняем функцию SyncForWrite, имитируем долгую работу - 10 секунд. Отправляем нашу строку через поток в файл. Сбрасываем буфер записи с помощью flush

- `bool ReadLine(std::wstring& outLine);` - функция чтения одной строки. Здесь используем общую(разделяемую блокировку), выполняем функцию SyncForRead, имитируем долгую работу - 10 секунд. Пытаемся считать строку, если успешно - обновляем переменную позиции чтения - на какой мы остановились. Функция возвращает true если чтение строки выполнилось успешно, false если нет

- `void ReadPosReset();` - функция сброса позиции чтения

## Функции FunctionsSystem:

- `void clearScreen();` - функция очистки экрана

- `void pause();` - функция паузы

- `std::wstring NotEmptyString(const std::wstring& prompt);` - функция ввода строки с проверкой на пустоту

- `wchar_t NotEmptyChar();` - функция проверки потока ввода на пустоту
